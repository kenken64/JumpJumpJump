# PRP: 在线多人游戏实现 (Online Multiplayer Implementation)

## 问题陈述
为了将游戏扩展到本地合作模式之外，我们需要一个强大的在线多人游戏系统，允许玩家远程连接，共享同一个游戏世界，并进行实时互动，且游戏体验不受不同步或延迟的影响。

## 需求
- 实时玩家位置和状态同步
- 共享世界生成（种子）
- 同步敌人生成和行为
- 低延迟通信
- 重连处理
- 网络问题的调试功能

## 提议的解决方案

### 架构
1. **客户端-服务器模型**:
   - **前端**: React/Phaser 客户端作为视图和输入层。
   - **后端**: FastAPI 服务器配合 WebSockets 管理房间状态和消息广播。
2. **通信协议**: 基于 JSON 的 WebSocket 消息用于事件（移动、跳跃、生成、伤害）。
3. **主机权威逻辑**: "主机"（第一位玩家）负责非确定性游戏逻辑（例如敌人生成）以确保一致性。

## 实现细节

### 1. WebSocket 服务 (`frontend/src/services/OnlineCoopService.ts`)
- 管理到 `ws://localhost:8000/ws` 的 WebSocket 连接。
- 处理连接生命周期（连接、断开、错误）。
- 将传入的网络事件分发给 `GameScene`。
- 节流传出的位置更新以防止网络拥塞。

### 2. 同步策略

#### 玩家同步
- **位置**: 客户端发送包含 (x, y, 速度, 动画) 的 `PLAYER_MOVE` 事件。
- **插值**: 远程玩家在视觉上进行平滑处理以防止抖动。
- **ID 验证**: 严格检查确保客户端只能控制其分配的玩家 ID（玩家 1 或玩家 2）。

#### 世界同步
- **种子共享**: 主机生成随机种子并将其广播给加入的玩家。
- **确定性生成**: 两个客户端在 `WorldGenerator` 中使用相同的种子来创建相同的地形。

#### 敌人同步（主机权威）
- **问题**: 如果两个客户端都随机生成敌人，它们将不同步。
- **解决方案**:
  - 只有 **主机** (玩家 1) 运行敌人生成逻辑。
  - 主机发送包含类型、位置和 ID 的 `ENEMY_SPAWN` 事件。
  - 访客 (玩家 2) 监听这些事件并实例化镜像主机模拟的 "幽灵" 敌人。

### 3. 后端基础设施 (`backend/main.py`)
- **FastAPI WebSocketEndpoint**: 处理并发连接。
- **房间管理**: 将连接分组到游戏会话中。
- **广播**: 将消息从一个客户端转发给同一房间内的其他客户端。
- **日志记录**: 详细的 `game_state.log` 捕获所有同步事件以进行调试（已从 git 中排除）。

### 4. 近期改进 (修复)
- **隐形敌人修复**: 在 `GameScene` 中添加了保护子句，防止访客在本地运行生成逻辑。添加了 `setVisible(true)` 强制显示同步敌人。
- **平台抖动修复**: 在 `WorldGenerator` 中实现了单向碰撞和全宽碰撞箱，以稳定浮动平台上的多人移动。
- **保存/加载系统**: 通过后端数据库实现了多人会话状态（生命、分数）的持久化。

## 技术规格

### 消息类型
```json
// 玩家移动
{
  "type": "PLAYER_MOVE",
  "payload": {
    "id": "player-1",
    "x": 100,
    "y": 200,
    "anim": "run"
  }
}

// 敌人生成 (主机 -> 访客)
{
  "type": "ENEMY_SPAWN",
  "payload": {
    "enemyId": "e_123",
    "x": 500,
    "y": 300,
    "type": "slime"
  }
}
```
